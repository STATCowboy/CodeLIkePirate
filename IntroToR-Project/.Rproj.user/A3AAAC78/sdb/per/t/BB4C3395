{
    "collab_server" : "",
    "contents" : "#\n# Intro to R\n# by: Jamey Johnston\n# @STATCowboy\n# http://STATCowboy.com\n#\n# July 29, 2017\n#\n\n# Let's Start Fresh (remove all objects in R Session)\nrm (list=ls())\n\n# Turn off warnings\noptions(warn=-1)\n\n#\n# Basics\n#\nm <- 3 * 5\nm\n\n#\n# Vector Examples\n#\n\n# c (combine) function to create a Vector\nv <- c(2, 3, 1.5, 3.1, 49)\nv\n\n# seq function generates numeric sequences\ns <- seq(from = 0, to = 100, by = .1)\ns\n\n# rep function replicates values\nr <- rep(c(1,4), times = 4)\nr\n\n# : creates a number sequence incremented by 1 or -1\ncolon <- 1:10\nprint(colon)\n\n# length of vector\nlength(colon)\n\n# sort vectors\ns <- c(2,3,4,1,10,8,9,7,6,0,5)\ns\ns2 <- sort(s)\ns2\n\n\n#\n# Matrices\n#\n\nm1 <- matrix(1, nr = 4, nc = 4)\nm2 <- matrix(2, nr = 4, nc = 4)\nm1\nm2\n\nrbind(m1, m2)\ncbind(m1, m2)\n\n#Product of two matrices is `%*%'. \nrbind(m1, m2) %*% cbind(m1, m2)\ncbind(m1, m2) %*% rbind(m1, m2)\n\n\n#\n# Data Frames\n#\n\ndf <- read.table(header = TRUE, stringsAsFactors=FALSE, text = \"\nid name sal\n1 Jamey 100\n2 Melanie 500\n3 Kevin 150\n4 Ken 150\n5 Regan 100\n6 Trey 100\n7 Robyn 100\n8 Stef 100\n9 Sherri 400\n10 Jimmy 300\n11 Jamey 120\n\")\nclass(df)\nView(df)\n\n\n# Column and Row Names\ncolnames(df)\nrownames(df)\n\n# Number of Rows in DF\nnrow(df)\nncol(df)\n\n\n\n\n# Reference Column in DF by name\ndf['name']\n\n# e.g. Change salary to sal * 1.05 (5% raise) use $ reference\ndf$sal <- df$sal*1.05\nView(df)\n\n# Accessing by Row or Column number [row,column]\ndf[1,]  # row\ndf[1,3] # cell\ndf[,2]  # column\n\n\n#\n# List\n#\n\nli <- list(m1, m2, colon, df)\nprint(li)\n\nli[[2]]\nli[[4]][1,]\n\n\n# LM Example\nView(anscombe)\n# Build Linear Model\nlmout <- lm(y3 ~ x3, data.frame(anscombe))\nsummary(lmout)\nanova(lmout)\nplot(lmout)\n\ntypeof(lmout)\n\n# Press Return in Console 4Xs\n\n# Output of lm is a class \"lm\"\nclass(lmout)\n\n#\n# Missing Values (NA)\n#\n\nx <- c(1.2,2.3,3.4,NA)\nprint(x)\n\n# Returns integer location of values (not the values)\nn <- which (is.na(x))\nv <- which (!is.na(x))\nprint(n)\nprint(v)\n\n# y will be set to the values not = NA\ny <- x[!is.na(x)]\nprint(y)\n\n# Set missing values to mean of x\nx[which (is.na(x))] <- mean(x[which(!is.na(x))])\nx\n\n\n\n#\n# Packages\n#\n\n# List Packages already installed\nlibrary()\n\n# Install package(s)\n# Uncomment the line below to actually run and install the packages if needed!!!!\n# install.packages(\"dplyr\", \"ggplot2\")\n\n# GGPlot2 Graph Example\n# Load ggplot2 Package\nlibrary(ggplot2)\nqplot(gear, mpg, data=mtcars, geom=c(\"boxplot\", \"jitter\"), \n    fill=gear, main=\"Mileage by Gear Number\",\n                xlab=\"\", ylab=\"Miles per Gallon\") \n\n#\n# Comparison Operations\n#\n\n1:10 == 2\n1:10 != 2\n1:10 > 2\n1:10 >= 2\n1:10 < 2\n1:10 <= 2\n\nx <- 2\nx > 1\nprint(x)\n\n\n#\n# Logical Operations\n#\n\nx <- 1:4\nx\n\n(x > 2) | (x <= 3)\n\n(x > 2) & (x <= 3)\n\nxor((x > 2), (x < 4))\n\n0:5 %in% x\n\n\n#\n# Control Flows\n#\n\n# IF Statements\nx <- 4\nif (x < 3) print(\"true\") else print(\"false\")\nifelse ((x < 3), print(\"true\"), print(\"false\"))\n\n# Nested Loops\n# Build upload \n\n# FOR Loops\n# Simple Loop outputting Vector\nfor(i in 1:10) \n  print(1:i)\n\n# Loop through data frame and print row at a time\nfor (i in 1:nrow(df))\n  print(df[i,])\n\n# WHILE Loops\ni <- 1\nwhile (i <= 10) \n{\n  print(i)\n  i <- i + 1\n}\n\n\n#\n# Functions\n#\n\n# Create Function to calculate Bonus\nbonus <- function(sal)\n{\n  bon <- sal * 1.05\n  return(bon)\n}\n\n# View Data BEFORE Bonus\nView(df)\n\n# Create new DataFrame to compare old vs new Sals after Bonus Calc\ndfBon <- df\n\n# Run Function to Calculate Bonus\ndfBon$sal <- bonus(dfBon$sal)\n\n# View Data BEFORE Bonus\nView(dfBon)\n\n\n#\n# Try/Catch\n#\n# http://adv-r.had.co.nz/Exceptions-Debugging.html\noptions(show.error.messages = TRUE)\nresults <- try(\"a\" + \"b\")\nprint(results)\n\noptions(show.error.messages = FALSE)\nresults <- try(\"a\" + \"b\")\nprint(results)\n\n\n#\n# DyGraphs\n#\n\nlibrary(dygraphs)\nlibrary(fma)\nlibrary(forecast)\ndygraph(pigs)\ndygraph(pigs, main = \"Monthly Pigs Slaughtered - Victoria\") %>%  # PIPE\n  dyRangeSelector(dateWindow = c(\"1980-01-01\", \"1996-01-01\"))\n\n\n#\n# Write Sample Data to CSV File\n#\nView(mtcars)\nwrite.csv(mtcars, file=\"mtcars.csv\", append=FALSE, sep=\",\", col.names = TRUE)\n\n\n#\n# More Fun with List\n# \n# These examples below all do the same thing calculate the final grade for\n# for each student using different techniques in R\n#\nclassGrades <- read.table(header = TRUE, stringsAsFactors = FALSE ,text = \"\nname Test Score\nJamey MidTerm 40\nJamey Project 50\nJamey Final 30\nMelanie MidTerm 100\nMelanie Project 100\nMelanie Final 100\nKevin MidTerm 95\nKevin Project 98\nKevin Final 92\nKen MidTerm 80\nKen Project 90\nKen Final 70\n\")\n\nmean(classGrades$Score)\n\n\nlibrary(dplyr)\nlibrary(tidyr)\n\n# \n# Option 1\n# Pivot via Spread and apply\n# \nclassGrades.FinalGrade <- spread(classGrades, Test, Score)\nclassGrades.FinalGrade\nclassGrades.FinalGrade$FinalGrade <- apply(classGrades.FinalGrade[,2:4],1,mean)\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- NULL\n\n#\n# For Loop Option 2a\n# Really bad code (on purpose for demonstration!!!!)\n#\nclassGrades\nclassGrades <- classGrades[order(classGrades$name),]\nclassGrades\n\ntotalScores <- classGrades$Score[1]\ncntScores <- 1\nclassGrades.FinalGrade <- data.frame(name=character(), \n                                     Test=character(), \n                                     Score=numeric(), stringsAsFactors = FALSE)\n\n# Start with Row 2 (set Row 1 above)\nfor (i in 2:nrow(classGrades))\n{\n  prevName <- as.character(classGrades$name[i-1])\n  if (classGrades$name[i] == prevName)\n  {\n    totalScores <- totalScores+classGrades$Score[i]\n    cntScores <- cntScores+1\n  }\n  else\n  {\n    classGrades.FinalGrade[nrow(classGrades.FinalGrade)+1,] <- \n      c(as.character(prevName), \"FinalGrade\", as.numeric(totalScores/cntScores))\n    totalScores <- classGrades$Score[i]\n    cntScores <- 1\n  }\n  if (i == nrow(classGrades)) classGrades.FinalGrade[nrow(classGrades.FinalGrade)+1,] <- \n      c(as.character(prevName), \"FinalGrade\", as.numeric(totalScores/cntScores))\n}\n\nclassGrades\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- rbind(classGrades, classGrades.FinalGrade)\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- NULL\n\n\n#\n# For Loop Option 2b\n# Good For Loop code but better methods (above and below)\n# as For Loops are slow!\n#\n\nnames <- unique(classGrades$name)\n\nclassGrades.FinalGrade <- data.frame(name=character(), \n                                     Test=character(), \n                                     Score=numeric(), stringsAsFactors = FALSE)\n\nfor (i in 1:length(names))\n{\n  grades <- classGrades[classGrades$name == names[i],]\n  classGrades.FinalGrade[nrow(classGrades.FinalGrade)+1,] <- \n       c(as.character(names[i]), \"FinalGrade\", \n         as.numeric(base::mean(grades$Score)))\n}\n\nclassGrades\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- rbind(classGrades, classGrades.FinalGrade)\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- NULL\n\n# \n# Option 3\n# Split by name into a list of data frames and use lapply (list apply)\n#\nclassGrades.list <- split(classGrades, classGrades$name)\nclassGrades.list\n\nclass(classGrades.list)\nclass(classGrades.list[[\"Jamey\"]])\n\n# classGrades.FinalGrade <- sapply(classGrades.list, function(x) {mean(x$Score)})\nclassGrades.FinalGrade <- \n  as.data.frame(do.call(\"rbind\", \n                        lapply(classGrades.list, \n                               function(x) {mean(x$Score)})))\nclassGrades.FinalGrade <- \n  cbind(names(classGrades.list), classGrades.FinalGrade)\nrownames(classGrades.FinalGrade) <- NULL\nnames(classGrades.FinalGrade) <- c(\"name\", \"FinalGrade\")\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- \n  left_join(classGrades, classGrades.FinalGrade, by=\"name\")\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- NULL\n\n#\n# Option 4 (add rows)\n#\nclassGrades.FinalGrade <- \n  as.data.frame(do.call(\"rbind\", \n                        lapply(classGrades.list, function(x) {mean(x$Score)})))\nclassGrades.FinalGrade <- \n  cbind(names(classGrades.list), \"FinalGrade\", classGrades.FinalGrade)\nrownames(classGrades.FinalGrade) <- NULL\nnames(classGrades.FinalGrade) <- c(\"name\", \"Test\", \"Score\")\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- rbind(classGrades, classGrades.FinalGrade)\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- \n  classGrades.FinalGrade[order(classGrades.FinalGrade$name),]\nclassGrades.FinalGrade\n\n# Alternative (dplyr)\nclassGrades.FinalGrade <- arrange(classGrades.FinalGrade, name)\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- NULL\n\n#\n# Option 5 (sqldf)\n#\nlibrary(sqldf)\nsel <- \"select name, 'FinalGrade' as Test, avg(Score) as Score\n        from classGrades\n        group by name\"\nclassGrades.FinalGrade <- sqldf(sel)\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- rbind(classGrades, classGrades.FinalGrade)\nclassGrades.FinalGrade\n\nclassGrades.FinalGrade <- \n  classGrades.FinalGrade[order(classGrades.FinalGrade$name),]\nclassGrades.FinalGrade\n\n\n# Install R Package in SQL Server 2016+\n#\n#\nlib.SQL <- \"C:\\\\Program Files\\\\Microsoft SQL Server\\\\MSSQL14.MSSQLSERVER\\\\R_SERVICES\\\\library\"\ninstall.packages(\"e1071\", lib = lib.SQL)  \n\n\n\n# \n# RODBC\n# Connect to DB via ODBC (SQL Server example)\n#\nlibrary(RODBC)\n\ndbhandle <- odbcDriverConnect('driver={SQL Server};server=.;database=msdb;trusted_connection=true')\nres <- sqlQuery(dbhandle, 'select * from information_schema.tables')\nclass(res)\nView(res)\n\n\n\n# Remote Connect to R Services in SQL Server and compute in SQL Server Context\nsqlServerConnString <- \"Driver=SQL Server;Server=.;Database=IntroToR;trusted_connection=true\";\n#sqlCompute <- RxInSqlServer(connectionString = sqlServerConnString,shareDir = sqlShareDir,wait = sqlWait,consoleOutput = sqlConsoleOutput);\n#rxSetComputeContext(sqlCompute);\nsqlServerSepal <- RxSqlServerData(sqlQuery = \"select [Sepal.Length] from [dbo].[iris_data]\", connectionString = sqlServerConnString, colInfo = list(Sepal.Length = list(type = \"float64\")));\nsqlServerSepal\n\n# Execute in the \nrxHistogram(~Sepal.Length,data=sqlServerSepal,histType=\"Percent\");\n\n# Bring data from SQL Server into DataFrame\ndf <- rxImport(inData=sqlServerSepal)\nView(df)\n\n\n\n\n#\n# Generate Sample Data for Logit Test\n\n# The logistic function is\n# f(x) = exp(x) / (exp(x) + 1) = 1 / (1 + exp(-x))\ninvlogit = function(x) { 1/(1+exp(-x)) }\n\nn <- 100000\nx1 <- rnorm(n)\nx2 <- rbinom(n, 1, .5)\nx3 <- rbinom(n, 1, .5)\nb0 <- 1; b1 <- 1.5; b2<- 2; b3 <- 2.5;\ny <- rbinom(n, 1, invlogit(b0 + b1*x1 + b2*x2 + b3*x3))\n\nlogdata <- as.data.frame(cbind(y,x1,x2,x3))\n\nmylogit <- glm(y ~ x1 + x2 + x3, data=logdata, family=\"binomial\") \n\nsummary(mylogit)\nconfint(mylogit, level=.95)\nplot(mylogit)\n\n",
    "created" : 1505311011552.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "3100165375",
    "id" : "BB4C3395",
    "lastKnownWriteTime" : 1505322322,
    "last_content_update" : 1505322322769,
    "path" : "C:/Users/jj/OneDrive/Documents/Statistics/R/Into-to-R-Session/IntroToR-Project/Into2R.R",
    "project_path" : "Into2R.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}